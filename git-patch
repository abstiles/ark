#!/usr/bin/env bash

USAGE="[options] [-i] <patchfile>"

LONG_USAGE="Applies a patch file like those generated by git diff. The changes from the
diff are staged in preparation for a commit.

All options are interpreted as options for the \`patch' command, with the
exception of the '-p' option, which is ignored. If '-' is given as patchfile,
the patch is read from stdin."

SUBDIRECTORY_OK=1

get_real_path () {
	echo $(python -c 'import os, sys; print os.path.realpath(sys.argv[1])' "$1")
}

VERBOSE=0
log_verbose () {
	if [[ "$VERBOSE" == 1 ]]; then
		echo "$@"
	fi
}

. "$(git --exec-path)/git-sh-setup"

if [[ $# == 0 ]]; then
	usage
	exit 1
fi

if [[ $1 == '-' || $1 != -* ]]; then
	# If the first argument looks like a patchfile name, treat it as one.
	patchfile=$1
	shift
elif [[ $* != *\ -i\ * ]]; then
	# If the '-i' argument is not given, assume the patchfile is the last arg
	# unless the last arg looks like an option
	arg=${BASH_ARGV[0]}
	if [[ $arg != -* ]]; then
		patchfile=$arg
		# Remove the last argument from the arg list.
		set -- "${@:1:$(($#-1))}"
	fi
fi

DRY_RUN=0
patch_args=()
git_args=()
git_add_args=()
git_rm_args=()
while [ -n "$*" ]; do
	arg=$1
	case $arg in
		--help|-h)
			# git intercepts --help and -h iff they are the first option given,
			# but I'm more flexible.
			echo "$LONG_USAGE"
			exit
			;;
		--verbose|-v)
			VERBOSE=1
			patch_args+=("--verbose")
			;;
		--dry-run)
			# If the --dry-run option is given, we'll skip modifying the stage
			DRY_RUN=1
			git_args+=("$1")
			git_add_args+=("--ignore-missing")
			git_rm_args+=("--ignore-unmatch")
			patch_args+=("$1")
			;;
		-i)
			# Catch the -i argument if it's specified since we always supply it
			shift
			if [[ -n "$patchfile" ]]; then
				echo "Error parsing arguments. Patchfile specified as " \
				"'$patchfile' and as '$1'. Only one patchfile allowed." | fmt
				echo
				usage
				exit 1
			fi
			patchfile=$1
			;;
		*)
			patch_args+=("$1")
			;;
	esac
	shift
done

# The patch must be applied at the top level, so we need an absolute path to
# the patch file if a relative path is given
patchfile=$(get_real_path "$patchfile")
OLDDIR=`pwd`
require_work_tree_exists
cd_to_toplevel

# It's unwise to blindly apply a patch to a dirty working directory.
#require_clean_work_tree "apply patch" \
#	"Please stash them or destroy them (e.g., with \"git reset --hard\")."

patch -i "$patchfile" "${patch_args[@]}" -p3 | while read line
do
	# Patch reports all modified files with lines reading:
	# "patching file <filename>". I want to stage all file modifications.
	if (echo $line | grep '^[Pp]atching file .\+' &>/dev/null); then
		log_verbose $line
		filename=`echo $line | sed 's/\(.*\) using Plan.*\.\.\./\1/' | \
			cut -d' ' -f3-`
		if [[ -f "$filename"  || $DRY_RUN == 1 ]]; then
			# Add the update to the stage
			echo "Updating $filename"
			git add "${git_args[@]}" "${git_add_args[@]}" "$filename" >/dev/null
			log_verbose git add "${git_args[@]}" "${git_add_args[@]}" "$filename"
		else
			# Remove the file from the stage if it's gone
			echo "Deleting $filename"
			git rm "${git_args[@]}" "${git_rm_args[@]}" "$filename" >/dev/null
			log_verbose git rm "${git_args[@]}" "${git_rm_args[@]}" "$filename"
		fi
	else
		# Allow other output from patch to transparently pass through
		echo $line
	fi
done

# Restore the user's previous working directory
cd $OLDDIR
if [[ $DRY_RUN == 0 ]]; then git status; fi
